{{/*
Pre-upgrade hook to safely migrate AWS-specific default apps from App CRs to HelmReleases.

Uses operatorkit's paused annotation to prevent race conditions with both
app-operator and chart-operator during the migration:

Phase 1: Pause all App CRs (prevents app-operator from recreating Chart CRs)
Phase 2: Pause + remove finalizers + delete Chart CRs (prevents chart-operator
         from re-adding finalizers or uninstalling Helm releases)
Phase 3: Remove finalizers + delete App CRs

Flux then adopts the existing Helm releases via the new HelmRelease CRs.

Note: The cluster subchart has its own migration hook for generic apps.
This hook handles only AWS-specific apps.
*/}}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "resource.default.name" $ }}-migrate-aws-apps
  namespace: {{ $.Release.Namespace }}
  labels:
    {{- include "labels.common" $ | nindent 4 }}
  annotations:
    helm.sh/hook: pre-upgrade
    helm.sh/hook-weight: "-5"
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
spec:
  backoffLimit: 3
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      labels:
        {{- include "labels.common" $ | nindent 8 }}
    spec:
      serviceAccountName: {{ include "resource.default.name" $ }}-migrate-aws-apps
      restartPolicy: Never
      containers:
      - name: kubectl
        image: gsoci.azurecr.io/giantswarm/kubectl:{{ .Values.cluster.providerIntegration.kubernetesVersion }}
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          runAsGroup: 1000
          allowPrivilegeEscalation: false
          seccompProfile:
            type: RuntimeDefault
          capabilities:
            drop:
            - ALL
        resources:
          requests:
            cpu: 10m
            memory: 64Mi
          limits:
            cpu: 100m
            memory: 256Mi
        command:
        - /bin/sh
        - -c
        - |
          set -eu
          CLUSTER_NAME="{{ include "resource.default.name" $ }}"
          MC_NAME="{{ .Values.global.managementCluster }}"
          NAMESPACE="{{ $.Release.Namespace }}"
          CHART_NAMESPACE="giantswarm"

          # Fetch MC kubeconfig (for in-cluster app Chart CRs on the MC)
          # The MC kubeconfig secret is always in the org-giantswarm namespace.
          echo "Fetching MC kubeconfig for $MC_NAME"
          kubectl get secret -n "org-giantswarm" "${MC_NAME}-kubeconfig" \
            -o jsonpath='{.data.value}' | base64 -d > /tmp/mc-kubeconfig

          MC="--kubeconfig /tmp/mc-kubeconfig"

          # Fetch WC kubeconfig (for normal WC app Chart CRs and sub-app Chart CRs)
          echo "Fetching WC kubeconfig for $CLUSTER_NAME"
          kubectl get secret -n "$NAMESPACE" "${CLUSTER_NAME}-kubeconfig" \
            -o jsonpath='{.data.value}' | base64 -d > /tmp/wc-kubeconfig

          WC="--kubeconfig /tmp/wc-kubeconfig"

          # Helper: remove finalizers and delete an App CR.
          # This prevents app-operator from recreating Chart CRs
          # between the Chart CR cleanup and the Helm upgrade.
          delete_app() {
            local app_name="$1"

            if ! kubectl get apps.application.giantswarm.io "$app_name" -n "$NAMESPACE" > /dev/null 2>&1; then
              echo "  App CR $app_name not found, skipping"
              return
            fi

            echo "  Removing finalizers from App CR $app_name"
            kubectl patch apps.application.giantswarm.io "$app_name" -n "$NAMESPACE" --type=json \
              -p='[{"op": "remove", "path": "/metadata/finalizers"}]' 2>/dev/null || \
              echo "  No finalizers to remove or already deleted"

            echo "  Deleting App CR $app_name"
            kubectl delete apps.application.giantswarm.io "$app_name" -n "$NAMESPACE" --ignore-not-found=true
          }

          # Helper: pause, remove finalizers, and delete a Chart CR.
          # The paused annotation prevents chart-operator from re-adding
          # its finalizer (race condition) and from uninstalling the Helm release.
          cleanup_chart() {
            local target="$1"  # "--kubeconfig <path>"
            local chart_name="$2"
            local location="$3" # "MC" or "WC", for logging

            if ! kubectl $target get chart "$chart_name" -n "$CHART_NAMESPACE" > /dev/null 2>&1; then
              echo "  Chart CR $chart_name not found on $location, skipping"
              return
            fi

            echo "  Pausing chart-operator reconciliation for $chart_name on $location"
            kubectl $target annotate chart "$chart_name" -n "$CHART_NAMESPACE" \
              "operatorkit.giantswarm.io/paused=true" --overwrite 2>/dev/null || \
              echo "  Failed to pause, continuing anyway"

            echo "  Removing finalizers from Chart CR $chart_name on $location"
            kubectl $target patch chart "$chart_name" -n "$CHART_NAMESPACE" --type=json \
              -p='[{"op": "remove", "path": "/metadata/finalizers"}]' 2>/dev/null || \
              echo "  No finalizers to remove or already deleted"

            echo "  Deleting Chart CR $chart_name on $location"
            kubectl $target delete chart "$chart_name" -n "$CHART_NAMESPACE" --ignore-not-found=true
          }

          # --- Phase 1: Pause all App CRs ---
          # Prevents app-operator from reconciling and recreating Chart CRs
          # during cleanup. Uses operatorkit's paused annotation.
          ALL_APPS="
            ${CLUSTER_NAME}-aws-nth-bundle
            ${CLUSTER_NAME}-cert-manager-crossplane-resources
            ${CLUSTER_NAME}-cilium-crossplane-resources
            ${CLUSTER_NAME}-aws-pod-identity-webhook
            ${CLUSTER_NAME}-aws-ebs-csi-driver-smons
            ${CLUSTER_NAME}-irsa-servicemonitors
          "
          echo "Phase 1: Pausing all App CRs to prevent app-operator reconciliation"
          for APP_CR in $ALL_APPS; do
            APP_CR=$(echo "$APP_CR" | tr -d '[:space:]')
            [ -z "$APP_CR" ] && continue
            if kubectl get apps.application.giantswarm.io "$APP_CR" -n "$NAMESPACE" > /dev/null 2>&1; then
              echo "  Pausing App CR $APP_CR"
              kubectl annotate apps.application.giantswarm.io "$APP_CR" -n "$NAMESPACE" \
                "operatorkit.giantswarm.io/paused=true" --overwrite 2>/dev/null || true
            fi
          done

          # --- Phase 2: Clean up Chart CRs ---

          # --- In-cluster apps (Chart CRs on MC) ---
          # These apps are installed in the MC. They may contain sub-App CRs
          # whose Chart CRs live on the WC.
          IN_CLUSTER_APPS="
            aws-nth-bundle
            cert-manager-crossplane-resources
            cilium-crossplane-resources
          "

          for APP_SUFFIX in $IN_CLUSTER_APPS; do
            APP_SUFFIX=$(echo "$APP_SUFFIX" | tr -d '[:space:]')
            [ -z "$APP_SUFFIX" ] && continue

            MC_CHART_NAME="${CLUSTER_NAME}-${APP_SUFFIX}"
            echo "Processing in-cluster app: $MC_CHART_NAME"

            # Clean up the in-cluster app's own Chart CR on MC
            cleanup_chart "$MC" "$MC_CHART_NAME" "MC"

            # Discover sub-apps installed by this in-cluster app.
            # Sub-App CRs have annotation meta.helm.sh/release-name pointing
            # to the parent App CR name.
            echo "  Discovering sub-apps of $MC_CHART_NAME"
            SUB_APPS=$(kubectl get apps.application.giantswarm.io -n "$NAMESPACE" \
              -o jsonpath='{range .items[*]}{.metadata.annotations.meta\.helm\.sh/release-name}={.metadata.name}{"\n"}{end}' 2>/dev/null \
              | grep "^${MC_CHART_NAME}=" | cut -d= -f2) || true

            for SUB_APP in $SUB_APPS; do
              [ -z "$SUB_APP" ] && continue
              # Strip cluster prefix to get Chart CR name on WC
              WC_CHART_NAME="${SUB_APP#${CLUSTER_NAME}-}"
              echo "  Processing sub-app: $SUB_APP -> Chart CR $WC_CHART_NAME on WC"
              cleanup_chart "$WC" "$WC_CHART_NAME" "WC"
            done
          done

          # --- Normal WC apps (Chart CRs on WC) ---
          # Chart CR name = app name (cluster prefix stripped by app-operator)
          NORMAL_WC_APPS="
            aws-pod-identity-webhook
            aws-ebs-csi-driver-smons
            irsa-servicemonitors
          "

          for APP in $NORMAL_WC_APPS; do
            APP=$(echo "$APP" | tr -d '[:space:]')
            [ -z "$APP" ] && continue

            echo "Processing normal WC app: $APP"
            cleanup_chart "$WC" "$APP" "WC"
          done

          # --- Phase 3: Delete App CRs ---
          # App CRs were already paused in Phase 1, so app-operator won't
          # interfere. Removing finalizers and deleting completes the cleanup.
          echo "Phase 3: Deleting App CRs"
          for APP_CR in $ALL_APPS; do
            APP_CR=$(echo "$APP_CR" | tr -d '[:space:]')
            [ -z "$APP_CR" ] && continue
            delete_app "$APP_CR"
          done

          echo "AWS migration hook completed successfully"
